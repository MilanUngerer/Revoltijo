<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Revoltijo para Miriams y Maggies üëµ</title>
<style>
  :root{ --azul:#0a2342; --cardW:60px; --cardH:86px; }
  *{box-sizing:border-box}
  body {margin:0;font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;background:#fff;color:var(--azul);} 
  header {background:var(--azul);color:#fff;padding:10px;display:flex;flex-wrap:wrap;gap:8px;justify-content:space-between;align-items:center;}
  header h1 {margin:0;font-size:18px;}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .controls label{display:flex;gap:6px;align-items:center}
  .controls input{height:28px;padding:2px 6px;border-radius:6px;border:1px solid #97adc7;width:60px;text-align:center}
  .controls button{background:#103b73;color:#fff;border:0;border-radius:8px;padding:6px 10px;cursor:pointer}
  .controls button:disabled{opacity:.5;cursor:not-allowed}
  main {display:flex;min-height:calc(100vh - 56px);} 
  .table-area {flex:1;display:flex;flex-direction:column;background:#0c6a0c;position:relative;min-height:60vh}
  #playersBar{position:sticky;top:0;z-index:2;display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px 12px;background:rgba(255,255,255,.18);backdrop-filter:saturate(130%) blur(2px);border-bottom:1px solid rgba(255,255,255,.25);}  
  .chip{display:flex;align-items:center;gap:6px;background:#f8faff;color:var(--azul);border:1px solid var(--azul);border-radius:999px;padding:4px 10px;box-shadow:0 1px 0 rgba(0,0,0,.15)}
  #groups {flex:1;display:flex;flex-wrap:wrap;justify-content:center;align-items:flex-start;padding:16px;gap:10px;overflow:auto;}
  .group {background:rgba(255,255,255,0.92);border:2px solid var(--azul);border-radius:12px;padding:6px 6px 8px;min-width:100px;min-height:108px;display:flex;flex-direction:column;align-items:center;}
  .group-header {font-size:12px;margin-bottom:4px;color:#123;}
  .cards {display:flex;flex-wrap:wrap;gap:4px;justify-content:center;max-width:360px}
  .card {width:var(--cardW);height:var(--cardH);background:#fff;border:1px solid var(--azul);border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;margin:2px;font-weight:700;cursor:grab;user-select:none;box-shadow:0 2px 0 rgba(0,0,0,.25);} 
  .card.red{color:#c00}
  .card.selected{outline:3px solid #ff9800; outline-offset:1px; border-color:#ff9800; box-shadow:0 0 0 3px rgba(255,152,0,.35), inset 0 0 0 2px rgba(255,152,0,.55);} 
  .hand {background:#f8faff;border-top:2px solid var(--azul);padding:10px;position:sticky;bottom:0}
  .hand-cards {display:flex;flex-wrap:nowrap;gap:6px;justify-content:flex-start;overflow-x:auto;padding-bottom:6px}
  #newGroupTile{background:rgba(255,255,255,0.85);border:2px dashed var(--azul);border-radius:12px;padding:12px 14px;min-width:180px;text-align:center;font-size:12px;color:#123}
  .hint {font-size:12px;color:#345}
  aside {width:300px;border-left:1px solid #ccd6e0;padding:12px;overflow:auto;background:#f0f4fa;}
  #logPanel{font-size:12px;height:120px;overflow:auto;border:1px solid #ccd;background:#fff;}

  /* Responsivo: panel de mensajes al fondo */
  @media (max-width: 900px){
    main{flex-direction:column;min-height:100vh}
    aside{order:3;width:100%;border:0;border-top:1px solid #ccd6e0;max-height:180px}
    :root{ --cardW:68px; --cardH:98px; }
  }
  @media (max-width: 520px){
    header h1{font-size:16px}
    .controls{gap:6px}
    .controls label{font-size:12px}
    .controls button{padding:6px 8px}
    :root{ --cardW:72px; --cardH:102px; }
    .group-header{font-size:11px}
    aside{max-height:150px}
  }
</style>
</head>
<body>
<header>
  <h1>Revoltijo para Miriams y Maggies üëµ</h1>
  <div class="controls">
    <label>Computadora(s): <input id="botsInput" type="number" min="1" max="5" value="2"></label>
    <button id="newGameBtn">Nueva partida</button>
    <button id="groupBtn">Agrupar seleccionadas</button>
    <button id="undoBtn">Deshacer √∫ltimo grupo</button>
    <button id="hintBtn">Sugerir jugada</button>
    <button id="endTurnBtn">Terminar turno</button>
    <button id="showInstrBtn">Instrucciones</button>
  </div>
</header>
<main>
  <section class="table-area">
    <div id="playersBar"></div>
    <div id="groups">
      <div id="newGroupTile">Suelta aqu√≠ para <strong>nuevo grupo</strong><br><span class="hint">(usa 3 cartas de tu mano)</span></div>
    </div>
    <div class="hand">
      <div><strong id="playerLabel">Jugador 1</strong> ‚Äî Tu mano (<span id="handCount">0</span>)</div>
      <div class="hand-cards" id="handCards"></div>
    </div>
    <div id="instrPanel" style="display:none;padding:10px;background:#f8faff;border-top:1px solid #ccd">
      <strong>Reglas e instrucciones</strong><br>
      ‚Ä¢ 2 mazos. 12 cartas por jugador. Selecciona CPUs y crea partida.<br>
      ‚Ä¢ Entra bajando 3 cartas propias (tr√≠o/escala).<br>
      ‚Ä¢ L√≠mite por turno: 3 cartas jugadas <em>desde tu mano</em> (no cuentan las que retiraste de la mesa este turno).<br>
      ‚Ä¢ Puedes mover cartas entre grupos. Sets se pueden unificar arrastrando un set sobre otro del mismo n√∫mero.<br>
      ‚Ä¢ En <b>escalas</b>, puedes tomar de los <em>extremos</em> y tambi√©n continuar alrededor de A (p.ej. J-Q-K-A-2-3).<br>
      ‚Ä¢ En <b>tr√≠os/cuartetos</b>, puedes tomar cualquiera si el grupo restante sigue v√°lido (‚â•3).<br>
      ‚Ä¢ Si tomas cartas de la mesa, debes usarlas en el mismo turno o no podr√°s terminar.
    </div>
  </section>
  <aside>
    <h3>Mensajes</h3>
    <div id="logPanel"></div>
  </aside>
</main>
<canvas id="confettiCanvas" style="position:fixed;top:0;left:0;pointer-events:none;width:100%;height:100%;"></canvas>
<div id="granny" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;border:3px solid var(--azul);padding:20px;border-radius:12px;z-index:99;text-align:center;min-width:260px">
  <div style="font-size:54px;line-height:1.1">üëµ</div>
  <h2 style="margin:6px 0 0 0;">¬°Felicidades Mo√±o√±o!</h2>
</div>
<script>
// ====== Logger ======
function log(m){ const el=document.getElementById('logPanel'); if(el){ const ts=new Date().toLocaleTimeString(); el.innerHTML = `<div>[${ts}] ${m}</div>` + el.innerHTML; } try{ console.log(m); }catch(e){} }

// ====== Confetti & Granny ======
const grannyNode = document.getElementById('granny');
const confettiCanvas = document.getElementById('confettiCanvas');
let confettiAnimating=false;
function showGranny(msg, happy=true){
  grannyNode.querySelector('h2').textContent = msg;
  grannyNode.style.display='block';
  if(happy){ startConfetti(); } else { stopConfetti(); }
}
function startConfetti(){
  const c=confettiCanvas; const ctx=c.getContext('2d');
  c.width=window.innerWidth; c.height=window.innerHeight;
  const pieces=Array.from({length:200},()=>({x:Math.random()*c.width,y:Math.random()*c.height,dy:2+Math.random()*3,color:`hsl(${Math.random()*360},100%,50%)`}));
  confettiAnimating=true;
  (function draw(){ if(!confettiAnimating) return; ctx.clearRect(0,0,c.width,c.height); pieces.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x,p.y,5,5);p.y+=p.dy;if(p.y>c.height)p.y=0;}); requestAnimationFrame(draw); })();
}
function stopConfetti(){ confettiAnimating=false; const c=confettiCanvas; const ctx=c.getContext('2d'); ctx.clearRect(0,0,c.width,c.height); }

// ====== Utilidades ======
const SUITS=["‚ô†","‚ô•","‚ô¶","‚ô£"], RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RING=["A","2","3","4","5","6","7","8","9","10","J","Q","K"]; // circular: A entre K y 2
const CIRCLE=[...RING, ...RING];
function rankVal(r,aceHigh=false){ if(r==='A')return aceHigh?14:1; if(r==='J')return 11; if(r==='Q')return 12; if(r==='K')return 13; return parseInt(r,10); }
function isSet(cards){ if(cards.length<3) return false; const r=cards[0].rank; return cards.every(c=>c.rank===r); }
function findRunSequence(cards){
  if(cards.length<3) return null; const s=cards[0].suit; if(!cards.every(c=>c.suit===s)) return null;
  const ranks=cards.map(c=>c.rank);
  if(new Set(ranks).size!==ranks.length) return null; // sin duplicados de rango
  for(let i=0;i<=CIRCLE.length-cards.length;i++){
    const seq=CIRCLE.slice(i, i+cards.length);
    if(ranks.every(r=>seq.includes(r)) && seq.every(r=>ranks.includes(r))) return seq;
  }
  return null;
}
function isRun(cards){ return !!findRunSequence(cards); }
function runEnds(group){ const seq=findRunSequence(group.cards); if(!seq) return null; return [seq[0], seq[seq.length-1]]; }
function isEndOfRun(group, card){ const ends=runEnds(group); if(!ends) return false; if(card.suit!==group.cards[0].suit) return false; return card.rank===ends[0] || card.rank===ends[1]; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

// ====== Estado ======
let state={ players:[], table:[], deck:[], current:0, decks:2 };
let turn=null; // {playedFromHand, enteredThisTurn, takenFromTable:Set, undo:[]}
let groupSeq=1; 
let selectedCards=new Set();   // selecci√≥n de mano
let selectedTable=new Set();   // selecci√≥n de cartas en mesa

// ====== Nueva partida ======
function buildDeck(decks){ const d=[]; for(let k=0;k<decks;k++){ for(const s of SUITS){ for(const r of RANKS){ d.push({id:`${r}${s}_${k}_${Math.random().toString(36).slice(2,7)}` ,rank:r,suit:s}); } } } return shuffle(d); }
function newGame(){
  stopConfetti(); grannyNode.style.display='none';
  const botsReq=Math.max(1,Math.min(5,parseInt(document.getElementById('botsInput').value||'2',10)));
  const total=Math.max(2, Math.min(6, 1 + botsReq)); // 1 humano + CPUs
  const decksSel=2; // siempre 2 mazos
  state={players:[], table:[], deck:buildDeck(decksSel), current:0, decks:decksSel};
  state.players.push({hand:[], ai:false, name:'Jugador 1', entered:false});
  for(let i=2;i<=total;i++){ state.players.push({hand:[], ai:true, name:`CPU ${i-1}`, entered:false}); }
  for(let r=0;r<12;r++){ for(let p=0;p<state.players.length;p++){ const c=state.deck.pop(); if(c) state.players[p].hand.push(c); }}
  groupSeq=1; startTurn(); renderAll(); log(`Nueva partida: ${total} jugadores (CPUs: ${total-1}), mazos: ${decksSel}.`);
}
function startTurn(){ turn={playedFromHand:0, enteredThisTurn:false, takenFromTable:new Set(), undo:[]}; selectedCards.clear(); selectedTable.clear(); renderAll(); log(`Turno de ${state.players[state.current].name}`); const p=state.players[state.current]; if(p.ai){ setTimeout(cpuPlay, 650); } }
function nextTurn(){ state.current=(state.current+1)%state.players.length; startTurn(); }

// ====== DnD helpers ======
function makeDrop(el, cb){ if(!el) return; el.addEventListener('dragover', ev=>ev.preventDefault()); el.addEventListener('drop', ev=>{ ev.preventDefault(); try{ const data=JSON.parse(ev.dataTransfer.getData('text/plain')); cb(data); }catch(e){} }); }

// ====== Render ======
function renderPlayers(){ const bar=document.getElementById('playersBar'); if(!bar) return; bar.innerHTML=''; if(!state.players||state.players.length===0){ bar.textContent='(sin jugadores)'; return; } state.players.forEach((p,i)=>{ const chip=document.createElement('div'); chip.className='chip'; const dot=document.createElement('span'); dot.textContent=(i===state.current?'‚óè':'‚óã'); dot.style.fontSize='12px'; const name=document.createElement('span'); name.textContent=p.name+(p.ai?' ü§ñ':'')+(p.entered?' ‚úì':''); name.style.fontWeight='600'; const cards=document.createElement('span'); cards.textContent=`(${p.hand.length})`; chip.appendChild(dot); chip.appendChild(name); chip.appendChild(cards); bar.appendChild(chip); }); }

function cardEl(c,from,groupId){ const d=document.createElement('div'); d.className='card'+((c.suit==='‚ô•'||c.suit==='‚ô¶')?' red':''); d.dataset.cardId=c.id; d.dataset.from=from; if(groupId!=null) d.dataset.groupId=groupId; d.innerHTML=`<div>${c.rank}</div><div>${c.suit}</div>`; d.addEventListener('click',()=>{ if(from==='hand'){ if(selectedCards.has(c.id)) selectedCards.delete(c.id); else selectedCards.add(c.id); renderHand(); } else if(from==='table'){ if(selectedTable.has(c.id)) selectedTable.delete(c.id); else selectedTable.add(c.id); renderTable(); } }); d.draggable=true; d.addEventListener('dragstart',ev=>{ ev.dataTransfer.setData('text/plain', JSON.stringify({cid:c.id, from, groupId})); }); if(from==='hand' && selectedCards.has(c.id)) d.classList.add('selected'); if(from==='table' && selectedTable.has(c.id)) d.classList.add('selected'); return d; }

function renderTable(){ const wrap=document.getElementById('groups'); if(!wrap) return; wrap.querySelectorAll('.group').forEach(n=>n.remove()); state.table.forEach((g,gi)=>{ const div=document.createElement('div'); div.className='group'; div.dataset.gid=g.id; const header=document.createElement('div'); header.className='group-header'; header.textContent=`Grupo ${gi+1} ‚Äî ${isSet(g.cards)?'Tr√≠o/Cuarteto':'Escala'} (${g.cards.length})`; const cc=document.createElement('div'); cc.className='cards'; g.cards.forEach(c=> cc.appendChild(cardEl(c,'table',g.id)) ); div.appendChild(header); div.appendChild(cc); const tile=document.getElementById('newGroupTile'); if(tile) wrap.insertBefore(div,tile); else wrap.appendChild(div); makeDrop(cc, payload=> onDropToGroup(payload,g.id));
    if('ontouchstart' in window){ div.addEventListener('click', ()=>{ const p=state.players[state.current]; if(p.ai) return; const selected=[...selectedCards].map(id=> state.players[0].hand.find(c=>c.id===id)).filter(Boolean); if(!selected.length) return; for(const card of selected){ if(turn.playedFromHand>=3 && !turn.takenFromTable.has(card.id)) break; if(canHangOnGroup(card,g)){ const idx=p.hand.findIndex(h=>h.id===card.id); if(idx>=0){ p.hand.splice(idx,1); g.cards.push(card); if(!turn.takenFromTable.has(card.id)) turn.playedFromHand++; selectedCards.delete(card.id); } } } renderAll(); }); }
  }); const tile=document.getElementById('newGroupTile'); if(tile){ makeDrop(tile, onDropToNewGroup); } }

function renderHand(){ const hand=document.getElementById('handCards'); if(!hand){ log('No se encontr√≥ contenedor de mano'); return; } hand.innerHTML=''; const me=state.players && state.players[0]; if(!me){ log('Jugadores no inicializados a√∫n'); return; } me.hand.forEach(c=> hand.appendChild(cardEl(c,'hand',null)) ); const hc=document.getElementById('handCount'); if(hc) hc.textContent=me.hand.length; const pl=document.getElementById('playerLabel'); if(pl) pl.textContent=me.name; makeDrop(hand, onDropToHand); }

function renderAll(){ try{ renderPlayers(); }catch(e){ log('Error renderPlayers: '+e); } try{ renderTable(); }catch(e){ log('Error renderTable: '+e); } try{ renderHand(); }catch(e){ log('Error renderHand: '+e); } }

// ====== Reglas de colgar ======
function canHangOnGroup(card, group){
  if(isSet(group.cards)){
    return group.cards[0].rank===card.rank; // sets ilimitados ‚â•3
  }
  if(isRun(group.cards)){
    if(card.suit!==group.cards[0].suit) return false;
    const seq=findRunSequence(group.cards); if(!seq) return false;
    const left = RING[(RING.indexOf(seq[0])+RING.length-1)%RING.length];
    const right= RING[(RING.indexOf(seq[seq.length-1])+1)%RING.length];
    return card.rank===left || card.rank===right;
  }
  return false;
}

// ====== Drops ======
function onDropToGroup(payload,destId){
  const p=state.players[state.current];
  const dest=state.table.find(g=>g.id===destId);
  if(!dest) return;
  if(payload.from==='hand'){
    if(!p.entered && !turn.enteredThisTurn){ log('Primero debes entrar con un tr√≠o o escala propios.'); return; }
    const i=p.hand.findIndex(c=>c.id===payload.cid); if(i<0) return; const card=p.hand[i];
    if(!canHangOnGroup(card,dest)){ log('Esa carta no cuelga en ese grupo.'); return; }
    if(!turn.takenFromTable.has(card.id) && turn.playedFromHand>=3){ log('L√≠mite de 3 cartas desde la mano por turno.'); return; }
    p.hand.splice(i,1); dest.cards.push(card);
    if(turn.takenFromTable.has(card.id)) turn.takenFromTable.delete(card.id); else turn.playedFromHand++;
    renderAll(); checkWin(p);
    return;
  }
  if(payload.from==='table'){
    if(!p.entered && !turn.enteredThisTurn){ log('Para reorganizar la mesa, primero entra con un grupo propio.'); return; }
    const src=state.table.find(g=>g.id===payload.groupId); if(!src) return;
    // Unificaci√≥n de sets del mismo rango
    if(isSet(src.cards) && isSet(dest.cards) && src.cards[0].rank===dest.cards[0].rank){ dest.cards.push(...src.cards); state.table=state.table.filter(g=>g!==src); renderAll(); return; }
    const idx=src.cards.findIndex(c=>c.id===payload.cid); if(idx<0) return; const moved=src.cards[idx];
    const afterSrc=src.cards.slice(0,idx).concat(src.cards.slice(idx+1));
    if(afterSrc.length>0 && !(isSet(afterSrc)||isRun(afterSrc))){ log('Quitar esa carta rompe el grupo de origen.'); return; }
    if(!canHangOnGroup(moved,dest)){ log('Esa carta no encaja en el grupo destino.'); return; }
    src.cards.splice(idx,1); selectedTable.delete(moved.id); dest.cards.push(moved);
    if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); }
    renderAll();
  }
}

function onDropToNewGroup(payload){
  const p=state.players[state.current];
  if(payload.from==='hand'){
    log('Para crear un nuevo grupo desde tu mano usa "Agrupar seleccionadas" (3 cartas).'); return;
  }
  if(payload.from==='table'){
    if(!p.entered && !turn.enteredThisTurn){ log('Para reorganizar la mesa primero debes entrar con un grupo propio.'); return; }
    const src=state.table.find(g=>g.id===payload.groupId); if(!src) return; const idx=src.cards.findIndex(c=>c.id===payload.cid); if(idx<0) return;
    const moved=src.cards[idx]; const after=src.cards.slice(0,idx).concat(src.cards.slice(idx+1));
    if(after.length>0 && !(isSet(after)||isRun(after))){ log('Quitar esa carta rompe el grupo de origen.'); return; }
    state.table.push({id:'g'+(groupSeq++), cards:[moved]}); src.cards.splice(idx,1); selectedTable.delete(moved.id); renderAll();
  }
}

function onDropToHand(payload){
  const p=state.players[state.current]; if(payload.from!=='table') return;
  if(!p.entered && !turn.enteredThisTurn){ log('Para retirar cartas de la mesa primero debes entrar con un grupo propio.'); return; }
  const src=state.table.find(g=>g.id===payload.groupId); if(!src) return; const idx=src.cards.findIndex(c=>c.id===payload.cid); if(idx<0) return; const moved=src.cards[idx];
  if(isRun(src.cards)){
    if(!isEndOfRun(src, moved)){ log('Solo puedes llevar a tu mano cartas de los extremos de una escala.'); return; }
  } else if(isSet(src.cards)){
    const afterSet=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(!(afterSet.length>=3 && isSet(afterSet))){ log('En sets, solo puedes llevar una carta si el grupo restante sigue v√°lido (‚â•3).'); return; }
  } else { log('Grupo inv√°lido.'); return; }
  const after=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(after.length>0 && !(isSet(after)||isRun(after))){ log('Dejar√≠a inv√°lido el grupo.'); return; }
  src.cards.splice(idx,1); p.hand.push(moved); if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); }
  if(!turn.takenFromTable) turn.takenFromTable=new Set(); turn.takenFromTable.add(moved.id); selectedTable.delete(moved.id); renderAll();
}

// ====== Botones ======
(function wireButtons(){
  document.getElementById('newGameBtn').onclick=newGame;
  document.getElementById('groupBtn').onclick=()=>{
    const p=state.players[state.current];
    const chosen=p.hand.filter(c=>selectedCards.has(c.id));
    if(chosen.length<3){ log('Selecciona al menos 3 cartas.'); return; }
    const countable=chosen.filter(c=>!turn.takenFromTable.has(c.id)).length;
    if(turn.playedFromHand + countable > 3){ log('Sobrepasas el l√≠mite de 3 cartas desde la mano.'); return; }
    if(!(isSet(chosen)||isRun(chosen))){ log('Las cartas seleccionadas no forman un grupo v√°lido.'); return; }
    chosen.forEach(c=>{ const i=p.hand.findIndex(h=>h.id===c.id); if(i>=0) p.hand.splice(i,1); });
    const gid='g'+(groupSeq++); state.table.push({id:gid, cards:chosen});
    turn.undo.push({type:'newGroup', gid, cards:chosen.map(c=>({...c})), playerIndex:state.current, countable});
    p.entered=true; turn.enteredThisTurn=true; turn.playedFromHand += countable; selectedCards.clear();
    renderAll(); checkWin(p);
  };
  document.getElementById('undoBtn').onclick=()=>{
    const action=turn.undo?.pop(); if(!action){ log('No hay nada que deshacer.'); return; }
    if(action.type!=='newGroup' || action.playerIndex!==state.current){ log('Solo puedes deshacer el √∫ltimo grupo que hiciste en este turno.'); return; }
    const idx=state.table.findIndex(g=>g.id===action.gid); if(idx<0){ log('No se encontr√≥ el grupo a deshacer.'); return; }
    const p=state.players[state.current]; const grp=state.table[idx]; p.hand.push(...grp.cards); state.table.splice(idx,1);
    turn.playedFromHand=Math.max(0, turn.playedFromHand - (action.countable||0)); selectedCards=new Set(grp.cards.map(c=>c.id)); renderAll();
  };
  document.getElementById('hintBtn').onclick=()=>{
    const p=state.players[state.current];
    for(let i=0;i<p.hand.length-2;i++){
      for(let j=i+1;j<p.hand.length-1;j++){
        for(let k=j+1;k<p.hand.length;k++){
          const combo=[p.hand[i],p.hand[j],p.hand[k]]; if(isSet(combo)||isRun(combo)){ selectedCards=new Set(combo.map(c=>c.id)); renderHand(); const firstSelId=combo[0]?.id; if(firstSelId){ const el=document.querySelector(`[data-card-id="${firstSelId}"]`); if(el){ el.scrollIntoView({inline:'center', behavior:'smooth', block:'nearest'}); } } log('Sugerencia marcada en la mano.'); return; }
        }
      }
    }
    log('No se encontr√≥ jugada sugerida.');
  };
  document.getElementById('endTurnBtn').onclick=()=>{
    const p=state.players[state.current];
    for(const g of state.table){ if(!(isSet(g.cards)||isRun(g.cards))){ log('La mesa no es v√°lida a√∫n.'); return; } }
    const handIds=new Set(p.hand.map(c=>c.id)); const pendientes=[...turn.takenFromTable].filter(id=>handIds.has(id));
    if(pendientes.length>0){ log('No puedes terminar: tienes cartas retiradas de la mesa sin usar.'); return; }
    if(turn.playedFromHand===0){ const card=state.deck.pop(); if(card){ p.hand.push(card); log(`${p.name} roba una carta.`); } }
    nextTurn();
  };
  document.getElementById('showInstrBtn').onclick=()=>{ const panel=document.getElementById('instrPanel'); panel.style.display = panel.style.display==='none'? 'block':'none'; };
})();

// ====== CPU (IA avanzada con revoltijo) ======
function handCombos(hand){
  const out=[];
  for(let i=0;i<hand.length-2;i++){
    for(let j=i+1;j<hand.length-1;j++){
      for(let k=j+1;k<hand.length;k++){
        const combo=[hand[i],hand[j],hand[k]]; if(isSet(combo)||isRun(combo)) out.push(combo);
      }
    }
  }
  return out;
}
function groupValidAfterRemoval(group, idx){ const after=group.cards.slice(0,idx).concat(group.cards.slice(idx+1)); if(after.length===0) return true; return isSet(after)||isRun(after); }
function canTakeFromGroup(group, idx){
  if(isRun(group.cards)){
    const ends=runEnds(group); if(!ends) return false; const card=group.cards[idx]; if(card.suit!==group.cards[0].suit) return false; if(card.rank!==ends[0] && card.rank!==ends[1]) return false; return groupValidAfterRemoval(group, idx);
  } else if(isSet(group.cards)){
    if(group.cards.length<4) return false; return groupValidAfterRemoval(group, idx);
  }
  return false;
}
function anyGroupAccepts(card, table=state.table){ for(const g of table){ if(canHangOnGroup(card,g)) return g.id; } return null; }
function copyTable(table){ return table.map(g=>({id:g.id, cards:g.cards.map(c=>({...c}))})); }
function tableGroupById(table, gid){ return table.find(g=>g.id===gid); }
function simulateMove(table, srcId, cardId, destId){
  const t=copyTable(table);
  const src=tableGroupById(t, srcId), dest=tableGroupById(t,destId); if(!src||!dest) return null;
  const idx=src.cards.findIndex(c=>c.id===cardId); if(idx<0) return null;
  const moved=src.cards[idx]; const after=src.cards.slice(0,idx).concat(src.cards.slice(idx+1));
  if(after.length>0 && !(isSet(after)||isRun(after))) return null;
  if(!canHangOnGroup(moved,dest)) return null;
  src.cards.splice(idx,1); dest.cards.push(moved);
  if(src.cards.length===0){ const pos=t.indexOf(src); if(pos>=0) t.splice(pos,1); }
  return t;
}
function simulateTakeToNewGroupWithTwoHand(table, srcId, cardId, handCards){
  // Solo valida mesa; contar cartas de mano lo hace el motor
  const t=copyTable(table);
  const src=tableGroupById(t, srcId); if(!src) return null;
  const idx=src.cards.findIndex(c=>c.id===cardId); if(idx<0) return null;
  // Chequear que sea legal tomarla
  const groupReal=tableGroupById(state.table, srcId); // para usar reglas exactas actuales
  const idxReal=groupReal.cards.findIndex(c=>c.id===cardId);
  if(!canTakeFromGroup(groupReal, idxReal)) return null;
  const taken=src.cards[idx]; src.cards.splice(idx,1);
  // Construye hipot√©tico grupo
  const trio=[taken, ...handCards];
  if(!(isSet(trio)||isRun(trio))) return null;
  t.push({id:'sim_'+Math.random().toString(36).slice(2,7), cards:trio});
  if(src.cards.length===0){ const pos=t.indexOf(src); if(pos>=0) t.splice(pos,1); }
  return t;
}
function findPlanToEnableCard(card, hand){
  // Si ya cuelga, no hace falta plan
  if(anyGroupAccepts(card)) return null;
  const table=state.table;
  // 1) mover una carta entre grupos para habilitar
  for(const src of table){
    for(const c of src.cards){
      const idx=src.cards.findIndex(x=>x.id===c.id); if(idx<0) continue;
      if(!groupValidAfterRemoval(src, idx)) continue;
      for(const dest of table){ if(dest.id===src.id) continue; if(!canHangOnGroup(c,dest)) continue;
        const t2=simulateMove(table, src.id, c.id, dest.id); if(!t2) continue;
        if(anyGroupAccepts(card, t2)) return {type:'move', srcId:src.id, cardId:c.id, destId:dest.id};
      }
    }
  }
  // 2) tomar de mesa (extremo o set>=4) y colgarla en otro grupo, luego colgar card
  for(const src of table){
    for(let i=0;i<src.cards.length;i++){
      if(!canTakeFromGroup(src, i)) continue; const taken=src.cards[i];
      for(const dest of table){ if(dest.id===src.id) continue; if(!canHangOnGroup(taken,dest)) continue;
        const t2=simulateMove(table, src.id, taken.id, dest.id); if(!t2) continue;
        if(anyGroupAccepts(card, t2)) return {type:'move', srcId:src.id, cardId:taken.id, destId:dest.id};
      }
    }
  }
  // 3) tomar de mesa y formar nuevo grupo con dos de la mano (reduce 2 de mano)
  if(turn.playedFromHand<=1){
    for(const src of table){
      for(let i=0;i<src.cards.length;i++){
        if(!canTakeFromGroup(src, i)) continue; const taken=src.cards[i];
        for(let a=0;a<hand.length-1;a++){
          for(let b=a+1;b<hand.length;b++){
            const A=hand[a], B=hand[b]; if(A.id===card.id||B.id===card.id) continue;
            const t2=simulateTakeToNewGroupWithTwoHand(table, src.id, taken.id, [A,B]);
            if(t2){ return {type:'newGroupFromTaken', srcId:src.id, cardId:taken.id, handA:A.id, handB:B.id}; }
          }
        }
      }
    }
  }
  return null;
}
function executePlan(plan, p){
  if(!plan) return false;
  if(plan.type==='move'){
    const src=state.table.find(g=>g.id===plan.srcId); const dest=state.table.find(g=>g.id===plan.destId); if(!src||!dest) return false;
    const idx=src.cards.findIndex(c=>c.id===plan.cardId); if(idx<0) return false; const moved=src.cards[idx];
    const after=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(after.length>0 && !(isSet(after)||isRun(after))) return false;
    if(!canHangOnGroup(moved,dest)) return false;
    src.cards.splice(idx,1); dest.cards.push(moved); if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); }
    log(`${p.name} (CPU) reacomoda ${moved.rank}${moved.suit}.`);
    return true;
  }
  if(plan.type==='newGroupFromTaken'){
    const src=state.table.find(g=>g.id===plan.srcId); if(!src) return false;
    const idx=src.cards.findIndex(c=>c.id===plan.cardId); if(idx<0) return false; const taken=src.cards[idx];
    // validar tomar
    const idxReal=idx; if(!canTakeFromGroup(src, idxReal)) return false;
    const Aidx=p.hand.findIndex(x=>x.id===plan.handA); const Bidx=p.hand.findIndex(x=>x.id===plan.handB);
    if(Aidx<0||Bidx<0) return false; const A=p.hand[Aidx], B=p.hand[Bidx];
    const combo=[taken,A,B]; if(!(isSet(combo)||isRun(combo))) return false;
    // ejecutar
    src.cards.splice(idx,1);
    const first=Math.max(Aidx,Bidx), second=Math.min(Aidx,Bidx);
    p.hand.splice(first,1); p.hand.splice(second,1);
    state.table.push({id:'g'+(groupSeq++), cards:[taken,A,B]});
    turn.playedFromHand+=2;
    log(`${p.name} (CPU) arma grupo usando carta de mesa + 2 de mano.`);
    if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); }
    return true;
  }
  return false;
}
function cpuPlay(){
  const p=state.players[state.current]; if(!p.ai) return;
  // 1) Entrar si a√∫n no entr√≥ (elige el primer combo v√°lido)
  if(!p.entered){ const combos=handCombos(p.hand); if(combos.length){ const combo=combos[0]; state.table.push({id:'g'+(groupSeq++), cards:combo}); p.hand=p.hand.filter(c=>!combo.includes(c)); p.entered=true; turn.playedFromHand+=3; log(`${p.name} (CPU) entra con un grupo.`); renderAll(); if(p.hand.length===0){ showGranny('¬°Para la pr√≥xima mo√±o√±o!', false); return; } } }
  let progressed=true, safety=50;
  while(progressed && safety-->0){
    progressed=false;
    // 2) colgar directo desde mano
    for(let h=0; h<p.hand.length && turn.playedFromHand<3; h++){
      const card=p.hand[h];
      for(const g of state.table){ if(canHangOnGroup(card,g)){ g.cards.push(card); p.hand.splice(h,1); h--; turn.playedFromHand++; progressed=true; log(`${p.name} (CPU) cuelga ${card.rank}${card.suit}.`); renderAll(); if(p.hand.length===0){ showGranny('¬°Para la pr√≥xima mo√±o√±o!', false); return; } break; } }
    }
    if(progressed) continue;
    // 3) plan: reacomodar mesa para habilitar colgada de alguna carta de mano
    if(turn.playedFromHand<3){
      let used=false;
      for(let h=0; h<p.hand.length && !used; h++){
        const card=p.hand[h]; if(anyGroupAccepts(card)) continue; // ya lo cubrir√≠a el paso 2
        const plan=findPlanToEnableCard(card, p.hand);
        if(plan){
          const ok=executePlan(plan, p); if(ok){
            // tras ejecutar, intenta colgar la carta objetivo
            for(const g of state.table){ if(canHangOnGroup(card,g)){ g.cards.push(card); p.hand.splice(h,1); turn.playedFromHand++; used=true; progressed=true; log(`${p.name} (CPU) cuelga ${card.rank}${card.suit} tras reacomodar.`); renderAll(); if(p.hand.length===0){ showGranny('¬°Para la pr√≥xima mo√±o√±o!', false); return; } break; } }
          }
        }
      }
      if(progressed) continue;
    }
    // 4) Si a√∫n queda margen (<=1 carta desde mano), intentar crear grupo con carta tomada + 2 de mano
    if(turn.playedFromHand<=1){
      outer:
      for(const src of state.table){
        for(let i=0;i<src.cards.length;i++){
          if(!canTakeFromGroup(src,i)) continue; const taken=src.cards[i];
          for(let a=0;a<p.hand.length-1;a++){
            for(let b=a+1;b<p.hand.length;b++){
              const A=p.hand[a], B=p.hand[b]; const combo=[taken,A,B];
              if((isSet(combo)||isRun(combo)) && turn.playedFromHand+2<=3){
                // ejecutar real
                src.cards.splice(i,1);
                const first=Math.max(a,b), second=Math.min(a,b);
                p.hand.splice(first,1); p.hand.splice(second,1);
                state.table.push({id:'g'+(groupSeq++), cards:[taken,A,B]});
                turn.playedFromHand+=2; progressed=true; log(`${p.name} (CPU) arma nuevo grupo (mesa+2 mano).`); renderAll(); if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); }
                break outer;
              }
            }
          }
        }
      }
    }
  }
  if(turn.playedFromHand===0){ const c=state.deck.pop(); if(c){ p.hand.push(c); log(`${p.name} (CPU) roba.`); } }
  nextTurn();
}
// ====== Win/Lose ======
function checkWin(p){ if(p.hand.length===0){ if(!p.ai){ showGranny('¬°Felicidades Mo√±o√±o!', true); } else { showGranny('¬°Para la pr√≥xima mo√±o√±o!', false); } } }

// ====== Errores ======
window.addEventListener('error', (e)=>{ log('‚ö†Ô∏è Error: '+ (e.message||e.error)); });

// init
if(document.readyState==='loading'){
  document.addEventListener('DOMContentLoaded', ()=>{ try{ newGame(); }catch(err){ log('Error al iniciar: '+err); } });
}else{ try{ newGame(); }catch(err){ log('Error al iniciar: '+err); } }
</script>
</body>
</html>

