<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Revoltijo ‚Äî Juego de Cartas</title>
<style>
  :root{ --azul:#0a2342; }
  body {margin:0;font-family:system-ui, sans-serif;background:#fff;color:var(--azul);} 
  header {background:var(--azul);color:#fff;padding:10px;display:flex;justify-content:space-between;align-items:center;}
  header h1 {margin:0;font-size:18px;}
  .controls label, .controls button, .controls select {margin-left:10px;}
  .controls button{background:#103b73;color:#fff;border:0;border-radius:8px;padding:6px 10px;cursor:pointer}
  .controls button:disabled{opacity:.5;cursor:not-allowed}
  main {display:flex;height:calc(100vh - 52px);} 
  aside {width:280px;border-right:1px solid #ccd6e0;padding:10px;overflow:auto;background:#f0f4fa;}
  .table-area {flex:1;display:flex;flex-direction:column;background:#0c6a0c;position:relative;}
  #playersBar{position:sticky;top:0;z-index:2;display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px 12px;background:rgba(255,255,255,.18);backdrop-filter:saturate(130%) blur(2px);border-bottom:1px solid rgba(255,255,255,.25);}  
  .chip{display:flex;align-items:center;gap:6px;background:#f8faff;color:var(--azul);border:1px solid var(--azul);border-radius:999px;padding:4px 10px;box-shadow:0 1px 0 rgba(0,0,0,.15)}
  #groups {flex:1;display:flex;flex-wrap:wrap;justify-content:center;align-items:flex-start;padding:16px;gap:10px;overflow:auto;}
  .group {background:rgba(255,255,255,0.92);border:2px solid var(--azul);border-radius:12px;padding:6px 6px 8px;min-width:88px;min-height:104px;display:flex;flex-direction:column;align-items:center;}
  .group-header {font-size:12px;margin-bottom:4px;color:#123;}
  .cards {display:flex;flex-wrap:wrap;gap:4px;justify-content:center;max-width:360px}
  .card {width:52px;height:74px;background:#fff;border:1px solid var(--azul);border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;margin:2px;font-weight:700;cursor:grab;user-select:none;box-shadow:0 2px 0 rgba(0,0,0,.25);} 
  .card.red{color:#c00}
  .card.selected{outline:3px solid #ff9800; outline-offset:1px}
  .hand {background:#f8faff;border-top:2px solid var(--azul);padding:10px;}
  .hand-cards {display:flex;flex-wrap:wrap;gap:6px;justify-content:center;}
  #newGroupTile{background:rgba(255,255,255,0.85);border:2px dashed var(--azul);border-radius:12px;padding:12px 14px;min-width:140px;text-align:center;font-size:12px;color:#123}
  .hint {font-size:12px;color:#345}
</style>
</head>
<body>
<header>
  <h1>Revoltijo ‚Äî Juego</h1>
  <div class="controls">
    <label>Jugadores: <input id="playersInput" type="number" min="2" max="6" value="3" style="width:50px"></label>
    <label>Computadora(s): <input id="botsInput" type="number" min="0" max="5" value="2" style="width:50px"></label>
    <label>Mazos: 
      <select id="decksInput"><option value="1" selected>1</option><option value="2">2</option></select>
    </label>
    <button id="newGameBtn">Nueva partida</button>
    <button id="groupBtn">Agrupar seleccionadas</button>
    <button id="hintBtn">Sugerir jugada</button>
    <button id="endTurnBtn">Terminar turno</button>
  </div>
</header>
<main>
  <aside>
    <h3>Estado</h3>
    <div id="statusInfo"></div>
    <h3>Mensajes</h3>
    <div id="logPanel" style="font-size:12px;height:180px;overflow:auto;border:1px solid #ccd;background:#fff;"></div>
    <p class="hint"></p>
  </aside>
  <section class="table-area">
    <div id="playersBar"></div>
    <div id="groups">
      <div id="newGroupTile">Suelta aqu√≠ para <strong>nuevo grupo</strong><br><span class="hint">(usa 3 cartas de tu mano)</span></div>
    </div>
    <div class="hand">
      <div><strong id="playerLabel">Jugador 1</strong> ‚Äî Tu mano (<span id="handCount">0</span>)</div>
      <div class="hand-cards" id="handCards"></div>
    </div>
  </section>
</main>
<script>
// ====== Logger ======
function log(m){ const el=document.getElementById('logPanel'); if(el){ const ts=new Date().toLocaleTimeString(); el.innerHTML = `<div>[${ts}] ${m}</div>` + el.innerHTML; } try{ console.log(m); }catch(e){} }

// ====== Utilidades ======
const SUITS=["‚ô†","‚ô•","‚ô¶","‚ô£"], RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
function rankVal(r,aceHigh=false){ if(r==='A')return aceHigh?14:1; if(r==='J')return 11; if(r==='Q')return 12; if(r==='K')return 13; return parseInt(r,10); }
function isSet(cards){ if(cards.length<3||cards.length>4) return false; const r=cards[0].rank; return cards.every(c=>c.rank===r); }
function isRun(cards){ if(cards.length<3) return false; const s=cards[0].suit; if(!cards.every(c=>c.suit===s)) return false; const ranks=cards.map(c=>c.rank);
  function check(ah){ const v=ranks.map(r=>rankVal(r,ah)).sort((a,b)=>a-b); for(let i=1;i<v.length;i++){ if(v[i]!==v[i-1]+1) return false; } return true; }
  return check(false)||check(true);
}
function isEndOfRun(group, card){ if(!isRun(group.cards)) return false; const suit=group.cards[0].suit; if(card.suit!==suit) return false; const lows = group.cards.map(c=>rankVal(c.rank,false)); const highs= group.cards.map(c=>rankVal(c.rank,true)); const minLow = Math.min(...lows), maxHigh= Math.max(...highs); const cLow = rankVal(card.rank,false), cHigh= rankVal(card.rank,true); return cLow===minLow || cHigh===maxHigh; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

// ====== Estado ======
let state={ players:[], table:[], deck:[], current:0, decks:1 };
let turn=null; // {playedFromHand, enteredThisTurn, takenFromTable:Set}
let groupSeq=1; let selectedCards=new Set();

// ====== Nueva partida ======
function buildDeck(decks){ const d=[]; for(let k=0;k<decks;k++){ for(const s of SUITS){ for(const r of RANKS){ d.push({id:`${r}${s}_${k}` ,rank:r,suit:s}); } } } return shuffle(d); }
function newGame(){
  const total=Math.max(2,Math.min(6,parseInt(document.getElementById('playersInput').value||'3',10)));
  const botsReq=Math.max(0,Math.min(5,parseInt(document.getElementById('botsInput').value||'2',10)));
  const decksSel=Math.max(1,Math.min(2,parseInt(document.getElementById('decksInput').value||'1',10)));
  const bots=Math.min(botsReq,total-1);
  state={players:[], table:[], deck:buildDeck(decksSel), current:0, decks:decksSel};
  state.players.push({hand:[], ai:false, name:'Jugador 1', entered:false});
  for(let i=2;i<=total;i++){ const ai=(i>total-bots); state.players.push({hand:[], ai, name:`Jugador ${i}${ai?' (CPU)':''}`, entered:false}); }
  for(let r=0;r<12;r++){ for(let p=0;p<state.players.length;p++){ const c=state.deck.pop(); if(c) state.players[p].hand.push(c); }}
  groupSeq=1; startTurn(); renderAll(); log(`Nueva partida: ${total} jugadores, ${bots} CPU, mazos: ${decksSel}.`);
}
function startTurn(){ turn={playedFromHand:0, enteredThisTurn:false, takenFromTable:new Set()}; selectedCards.clear(); renderAll(); log(`Turno de ${state.players[state.current].name}`); }
function nextTurn(){ state.current=(state.current+1)%state.players.length; startTurn(); const p=state.players[state.current]; if(p.ai){ setTimeout(cpuPlay, 700); } }

// ====== DnD helpers ======
function makeDrop(el, cb){ el.addEventListener('dragover', ev=>ev.preventDefault()); el.addEventListener('drop', ev=>{ ev.preventDefault(); try{ const data=JSON.parse(ev.dataTransfer.getData('text/plain')); cb(data); }catch(e){} }); }

// ====== Render ======
function renderPlayers(){ const bar=document.getElementById('playersBar'); if(!bar) return; bar.innerHTML=''; if(!state.players||state.players.length===0){ bar.textContent='(sin jugadores)'; return; } state.players.forEach((p,i)=>{ const chip=document.createElement('div'); chip.className='chip'; const dot=document.createElement('span'); dot.textContent=(i===state.current?'‚óè':'‚óã'); dot.style.fontSize='12px'; const name=document.createElement('span'); name.textContent=p.name+(p.ai?' ü§ñ':'')+(p.entered?' ‚úì':''); name.style.fontWeight='600'; const cards=document.createElement('span'); cards.textContent=`(${p.hand.length})`; chip.appendChild(dot); chip.appendChild(name); chip.appendChild(cards); bar.appendChild(chip); }); }

function cardEl(c,from,groupId){ const d=document.createElement('div'); d.className='card'+((c.suit==='‚ô•'||c.suit==='‚ô¶')?' red':''); d.dataset.cardId=c.id; d.dataset.from=from; if(groupId!=null) d.dataset.groupId=groupId; d.innerHTML=`<div>${c.rank}</div><div>${c.suit}</div>`; d.addEventListener('click',()=>{ if(from==='hand'){ if(selectedCards.has(c.id)) selectedCards.delete(c.id); else selectedCards.add(c.id); renderHand(); } else if(from==='table'){ d.classList.toggle('selected'); } }); d.draggable=true; d.addEventListener('dragstart',ev=>{ ev.dataTransfer.setData('text/plain', JSON.stringify({cid:c.id, from, groupId})); }); if(selectedCards.has(c.id)) d.classList.add('selected'); return d; }

function renderTable(){ const wrap=document.getElementById('groups'); wrap.querySelectorAll('.group').forEach(n=>n.remove()); state.table.forEach((g,gi)=>{ const div=document.createElement('div'); div.className='group'; div.dataset.gid=g.id; const header=document.createElement('div'); header.className='group-header'; header.textContent=`Grupo ${gi+1} ‚Äî ${isSet(g.cards)?'Tr√≠o/Cuarteto':'Escala'} (${g.cards.length})`; const cc=document.createElement('div'); cc.className='cards'; g.cards.forEach(c=> cc.appendChild(cardEl(c,'table',g.id)) ); div.appendChild(header); div.appendChild(cc); const tile=document.getElementById('newGroupTile'); if(tile) wrap.insertBefore(div,tile); else wrap.appendChild(div); makeDrop(cc, payload=> onDropToGroup(payload,g.id)); }); const tile=document.getElementById('newGroupTile'); if(tile){ makeDrop(tile, onDropToNewGroup); } }

function renderHand(){ const hand=document.getElementById('handCards'); hand.innerHTML=''; const p=state.players[0]; p.hand.forEach(c=> hand.appendChild(cardEl(c,'hand',null)) ); document.getElementById('handCount').textContent=p.hand.length; document.getElementById('playerLabel').textContent=p.name; makeDrop(hand, onDropToHand); }

function renderAll(){ renderPlayers(); renderTable(); renderHand(); updateStatus(); ensureHint(); }

function updateStatus(){ const box=document.getElementById('statusInfo'); box.innerHTML = state.players.map((p,i)=>{ const turnMark=(i===state.current?'üü¢':'‚ö™'); const ent=p.entered? '‚úîÔ∏è' : '‚Äî'; return `${turnMark} ${p.name}${p.ai?' (CPU)':''}: ${p.hand.length} cartas ¬∑ Entr√≥: ${ent}`; }).join('<br>'); }

// ====== Drop handlers ======
function onDropToGroup(payload,destId){ const p=state.players[state.current]; const dest=state.table.find(g=>g.id===destId); if(!dest) return; function canHang(card,group){ const type=isSet(group.cards)?'set':(isRun(group.cards)?'run':null); if(type==='set'){ if(group.cards.length>=4) return false; return group.cards[0].rank===card.rank; } if(type==='run'){ const suit=group.cards[0].suit; if(card.suit!==suit) return false; const sorted=group.cards.slice().sort((a,b)=>rankVal(a.rank,true)-rankVal(b.rank,true)); const lo=rankVal(sorted[0].rank,false), hi=rankVal(sorted[sorted.length-1].rank,true); const vLow=rankVal(card.rank,false), vHigh=rankVal(card.rank,true); return (vLow===lo-1)||(vHigh===hi+1);} return false; } if(payload.from==='hand'){ if(!p.entered && !turn.enteredThisTurn){ log('Primero debes entrar con un tr√≠o o escala propios.'); return; } const i=p.hand.findIndex(c=>c.id===payload.cid); if(i<0) return; const card=p.hand[i]; if(!canHang(card,dest)){ log('Esa carta no cuelga en ese grupo.'); return; } if(!turn.takenFromTable.has(card.id) && turn.playedFromHand>=3){ log('L√≠mite de 3 cartas desde la mano por turno.'); return; } p.hand.splice(i,1); dest.cards.push(card); if(turn.takenFromTable.has(card.id)) turn.takenFromTable.delete(card.id); else turn.playedFromHand++; renderAll(); if(p.hand.length===0){ alert(p.name+" gana la partida!"); } return; } if(payload.from==='table'){ if(!p.entered && !turn.enteredThisTurn){ log('Para reorganizar la mesa, primero entra con un grupo propio.'); return; } const src=state.table.find(g=>g.id===payload.groupId); if(!src) return; const idx=src.cards.findIndex(c=>c.id===payload.cid); if(idx<0) return; const moved=src.cards[idx]; const afterSrc=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(afterSrc.length>0 && !(isSet(afterSrc)||isRun(afterSrc))){ log('Quitar esa carta rompe el grupo de origen.'); return; } if(!canHang(moved,dest)){ log('Esa carta no encaja en el grupo destino.'); return; } src.cards.splice(idx,1); dest.cards.push(moved); if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); } renderAll(); } }

function onDropToNewGroup(payload){ const p=state.players[state.current]; if(payload.from==='hand'){ log('Para crear un nuevo grupo desde tu mano usa "Agrupar seleccionadas" (3 cartas).'); return; } if(payload.from==='table'){ if(!p.entered && !turn.enteredThisTurn){ log('Para reorganizar la mesa primero debes entrar con un grupo propio.'); return; } const src=state.table.find(g=>g.id===payload.groupId); if(!src) return; const idx=src.cards.findIndex(c=>c.id===payload.cid); if(idx<0) return; const moved=src.cards[idx]; const after=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(after.length>0 && !(isSet(after)||isRun(after))){ log('Quitar esa carta rompe el grupo de origen.'); return; } state.table.push({id:'g'+(groupSeq++), cards:[moved]}); src.cards.splice(idx,1); renderAll(); } }

function onDropToHand(payload){ const p=state.players[state.current]; if(payload.from!=='table') return; if(!p.entered && !turn.enteredThisTurn){ log('Para retirar cartas de la mesa primero debes entrar con un grupo propio.'); return; } const src=state.table.find(g=>g.id===payload.groupId); if(!src) return; const idx=src.cards.findIndex(c=>c.id===payload.cid); if(idx<0) return; const moved=src.cards[idx]; if(isRun(src.cards)){ if(!isEndOfRun(src, moved)){ log('Solo puedes llevar a tu mano cartas de los extremos de una escala.'); return; } } else if(isSet(src.cards)){ const afterSet=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(!(afterSet.length>=3 && isSet(afterSet))){ log('En tr√≠os/cuartetos, solo puedes llevar una carta si el grupo restante sigue v√°lido (m√≠n. 3 cartas).'); return; } } else { log('No puedes retirar cartas de un grupo inv√°lido.'); return; } const after=src.cards.slice(0,idx).concat(src.cards.slice(idx+1)); if(after.length>0 && !(isSet(after)||isRun(after))){ log('No puedes llevar esa carta: dejar√≠a inv√°lido el grupo.'); return; } src.cards.splice(idx,1); p.hand.push(moved); if(src.cards.length===0){ state.table=state.table.filter(g=>g!==src); } turn.takenFromTable.add(moved.id); renderAll(); }

// ====== Botones ======
(function wireButtons(){ document.getElementById('newGameBtn').onclick=newGame; document.getElementById('groupBtn').onclick=()=>{ const p=state.players[state.current]; const chosen=p.hand.filter(c=>selectedCards.has(c.id)); if(chosen.length<3){ log('Selecciona al menos 3 cartas.'); return; } const countable=chosen.filter(c=>!turn.takenFromTable.has(c.id)).length; if(turn.playedFromHand + countable > 3){ log('Sobrepasas el l√≠mite de 3 cartas desde la mano.'); return; } if(!(isSet(chosen)||isRun(chosen))){ log('Las cartas seleccionadas no forman un grupo v√°lido.'); return; } chosen.forEach(c=>{ const i=p.hand.findIndex(h=>h.id===c.id); if(i>=0) p.hand.splice(i,1); }); state.table.push({id:'g'+(groupSeq++), cards:chosen}); p.entered=true; turn.enteredThisTurn=true; turn.playedFromHand += countable; chosen.forEach(c=> turn.takenFromTable.delete(c.id)); selectedCards.clear(); renderAll(); log(`${p.name} baj√≥ un grupo.`); }; document.getElementById('hintBtn').onclick=()=>{ const p=state.players[state.current]; for(let i=0;i<p.hand.length-2;i++){ for(let j=i+1;j<p.hand.length-1;j++){ for(let k=j+1;k<p.hand.length;k++){ const combo=[p.hand[i],p.hand[j],p.hand[k]]; if(isSet(combo)||isRun(combo)){ selectedCards=new Set(combo.map(c=>c.id)); renderHand(); log('Sugerencia marcada en la mano.'); return; } } } } log('No se encontr√≥ jugada sugerida.'); }; document.getElementById('endTurnBtn').onclick=()=>{ const p=state.players[state.current]; for(const g of state.table){ if(!(isSet(g.cards)||isRun(g.cards))){ log('La mesa no es v√°lida a√∫n. Reorganiza hasta dejar solo tr√≠os/escales v√°lidas.'); return; } } const handIds=new Set(p.hand.map(c=>c.id)); const pendientes=[...turn.takenFromTable].filter(id=>handIds.has(id)); if(pendientes.length>0){ log('No puedes terminar: tienes en la mano cartas retiradas de la mesa. Debes usarlas en este turno.'); return; } if(turn.playedFromHand===0){ const card=state.deck.pop(); if(card){ p.hand.push(card); log(`${p.name} roba una carta.`); } } nextTurn(); }; })();

// ====== CPU ======
function cpuPlay(){ const p=state.players[state.current]; if(!p.ai) return; let played=false; for(let i=0;i<p.hand.length-2&&!played;i++){ for(let j=i+1;j<p.hand.length-1&&!played;j++){ for(let k=j+1;k<p.hand.length&&!played;k++){ const combo=[p.hand[i],p.hand[j],p.hand[k]]; if(isSet(combo)||isRun(combo)){ state.table.push({id:'g'+(groupSeq++), cards:combo}); p.hand=p.hand.filter(c=>!combo.includes(c)); p.entered=true; played=true; log(`${p.name} (CPU) baj√≥ un grupo.`); } } } } if(!played){ const card=state.deck.pop(); if(card){ p.hand.push(card); log(`${p.name} (CPU) roba.`); } } nextTurn(); }

// ====== Instrucciones en panel ======
function ensureHint(){ const hint=document.querySelector('.hint'); if(!hint) return; hint.innerHTML = `<strong>Reglas e instrucciones</strong><br>
‚Ä¢ Entra bajando 3 cartas propias (tr√≠o/escala).<br>
‚Ä¢ L√≠mite por turno: 3 cartas jugadas <em>desde tu mano</em> (no cuentan las que retiraste de la mesa este turno).<br>
‚Ä¢ Puedes mover cartas entre grupos.<br>
‚Ä¢ Para llevar una carta a tu mano: (a) en <b>escalas</b>, solo desde los <em>extremos</em>; (b) en <b>tr√≠os/cuartetos</b>, puedes tomar cualquiera <em>si el grupo restante sigue v√°lido (‚â•3)</em>.<br>
‚Ä¢ Si tomas cartas de la mesa, debes usarlas en el mismo turno o no podr√°s terminar.`; }

// ====== Tests de sanidad (en consola) ======
(function runTests(){
  console.assert(isSet([{rank:'7',suit:'‚ô†'},{rank:'7',suit:'‚ô•'},{rank:'7',suit:'‚ô¶'}])===true,'isSet trio');
  console.assert(isSet([{rank:'7',suit:'‚ô†'},{rank:'7',suit:'‚ô•'},{rank:'8',suit:'‚ô¶'}])===false,'isSet inv√°lido');
  console.assert(isRun([{rank:'A',suit:'‚ô£'},{rank:'2',suit:'‚ô£'},{rank:'3',suit:'‚ô£'}])===true,'isRun A-2-3');
  console.assert(isRun([{rank:'Q',suit:'‚ô¶'},{rank:'K',suit:'‚ô¶'},{rank:'A',suit:'‚ô¶'}])===true,'isRun Q-K-A');
  console.assert(isRun([{rank:'2',suit:'‚ô•'},{rank:'3',suit:'‚ô•'},{rank:'5',suit:'‚ô•'}])===false,'isRun hueco');
  const grpRun={cards:[{rank:'2',suit:'‚ô¶'},{rank:'3',suit:'‚ô¶'},{rank:'4',suit:'‚ô¶'}]};
  console.assert(isEndOfRun(grpRun,{rank:'2',suit:'‚ô¶'})===true,'extremo bajo');
  console.assert(isEndOfRun(grpRun,{rank:'4',suit:'‚ô¶'})===true,'extremo alto');
  console.assert(isEndOfRun(grpRun,{rank:'3',suit:'‚ô¶'})===false,'no extremo');
  const grpSet4={cards:[{rank:'9',suit:'‚ô†'},{rank:'9',suit:'‚ô•'},{rank:'9',suit:'‚ô¶'},{rank:'9',suit:'‚ô£'}]};
  const afterRemoveOne=[grpSet4.cards[0],grpSet4.cards[1],grpSet4.cards[2]];
  console.assert(afterRemoveOne.length>=3 && isSet(afterRemoveOne),'remover de cuarteto deja tr√≠o v√°lido');
})();

// init
newGame();
</script>
</body>
</html>
